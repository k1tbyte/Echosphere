import React, {FC, useCallback, useEffect, useState} from "react";import {    IVideoBitrate,    IVideoCodec,    IVideoPropsSchema,    EVideoCodecProvider,    IVideoCodecPreset} from "@/store/videoStore";import {Label} from "@/shared/ui/Label";import {SliderWithLabel, SliderWithMarks} from "@/shared/ui/Slider";import {Separator} from "@/shared/ui/Separator";import {Switch} from "@/shared/ui/Switch";import {MultiSelect, Select} from "@/shared/ui/Select";import {TypeQuality} from "@/pages/Home/StudioPage";import {Button} from "@/shared/ui/Button";import { SelectTrigger, SelectValue, SelectContent, SelectGroup, SelectItem, SelectLabel } from "@/shared/ui/Select";interface IVideoQualityDTO {    videoBitrate: number;    audioBitrate?: number;}export interface IVideoSettingsDTO {    thumbnailsCaptureInterval: number;    adaptive?:{        qualities: Record<string, IVideoQualityDTO>[];        video: {            codec: string;            preset: string;        },        audio: {            codec: string;            bitrate: number;        }    }}interface VideoSettingsSectionProps {    schema: IVideoPropsSchema;    videoQualities: TypeQuality;    settings: IVideoSettingsDTO;}type Quality = IVideoBitrate & { value: string, label: string, currentBitrate?: number };export const VideoSettingsSection: FC<VideoSettingsSectionProps> = ({ schema, videoQualities, settings }) => {    const getCodecPresets = (codec: IVideoCodec) => {        // @ts-ignore        return schema.codecPresets[codec.presets];    }    const getDefaultCodecPreset = (presets: Record<string, IVideoCodecPreset>[]) => {        for (const [key, preset] of Object.entries(presets)) {            if (preset.isDefault) {                return key;            }        }        return Object.keys(presets)[0] || "";    }    const [withHLS, setWithHLS] = useState(false);    const [withThumbnails, setWithThumbnails] = useState(false);    const [videoProps, setVideoProps] = useState<any>({})    const [qualities, setQualities] = useState<Quality[]>();    const [selectedQualities, setSelectedQualities] = useState<Quality[]>([]);    const [selectedQuality, setSelectedQuality] = useState<Quality | null>(null);    const [selectedCodec, setSelectedCodec] = useState<IVideoCodec>(schema.codecs[0]);    const [codecPresets, setCodecPresets] = useState<Record<string, IVideoCodec[]>>(getCodecPresets(selectedCodec));    // @ts-ignore    const [codecPreset, setCodecPreset] = useState<string>(getDefaultCodecPreset(codecPresets));    const [selectedAudioCodec, setSelectedAudioCodec] = useState<string>(Object.keys(schema.audioCodecs)[0] || "");    const [defaultAudioBitrate, setDefaultAudioBitrate] = useState<number>(schema.defaultAudioBitrate || 128);    const [captureInterval, setCaptureInterval] = useState<number[]>([schema.thumbnailsCaptureInterval.default || 5]);    const [_, setForceUpdate] = useState(false);    useEffect(() => {        let qualities: Quality[] = [];        const bitrates = Object.entries(schema.videoBitrates);        for (const quality of videoQualities) {            const bitrate = bitrates.find(([key]) => key == quality.value);                if (bitrate) {                    const [key, value] = bitrate;                    qualities.push({                        value: key,                        label: quality.label,                        ...value,                    });                }        }        setSelectedQuality(qualities[0] || null);        setSelectedQualities(qualities);        setQualities(qualities);    }, [videoQualities]);    useEffect(() => {        setCodecPreset(getDefaultCodecPreset(codecPresets));    }, [codecPresets])    useEffect(() => {        const s = Object.entries(schema.audioBitrates).map(([k, v]) => {            return {                value: v,                label: k + " kbps"            }        })    }, []);    settings.thumbnailsCaptureInterval = withThumbnails ? captureInterval[0] : 0;    if(withHLS) {        settings.adaptive = {            qualities: selectedQualities.reduce((acc, quality) => {                acc[quality.value] = {                    /*audioBitrate: defaultAudioBitrate,*/                    videoBitrate: quality.currentBitrate || quality.optimalBitrate                };                return acc;            }, {} as Record<string, IVideoQualityDTO>),            video: {                codec: selectedCodec.name,                preset: codecPreset            },            audio: {                codec: selectedAudioCodec,                bitrate: defaultAudioBitrate            }        }    } else {        settings.adaptive = undefined;    }    return (        <>            <div className="flex justify-between flex-y-center">                <Label size={"lg"}>                    Capture thumbnails                </Label>                <Switch  checked={withThumbnails} onCheckedChange={setWithThumbnails} />            </div>            { withThumbnails &&                <div className="w-full text-sm pt-9 font-medium">                    <SliderWithLabel                        defaultValue={captureInterval}                        min={schema.thumbnailsCaptureInterval.min}                        max={schema.thumbnailsCaptureInterval.max}                        step={1}                        labelAfter={" sec."}                        onValueCommit={setCaptureInterval}                        className={"w-full mb-1"}                    />                    <small className="text-xs font-normal text-muted-foreground">                        Smaller is more accurate, but takes more resources                    </small>                </div>            }            <Separator className="my-5"/>            <div className="flex justify-between flex-y-center">                <Label size={"lg"}>Adaptive quality settings                    <small className="ml-2 text-xs font-normal text-muted-foreground">                        (HLS)                    </small>                </Label>                <Switch  checked={withHLS} onCheckedChange={setWithHLS} />            </div>            { withHLS && qualities &&                <>                    <MultiSelect className="mt-3"                                 minSelected={1} onBadgeClick={setSelectedQuality}                                 onChange={(o) => {                                     setSelectedQualities(o)                                 }}                                 defaultValue={qualities.length ? qualities : []}                                 options={qualities}                                 placeholder="Select the quality to be supported"                    />                    { selectedQuality &&                        <div className="flex flex-col ml-2 px-3 border-l border-border border-dashed mb-4">                            <Label size={"md"} className="mb-3">Settings for {selectedQuality.label}</Label>                            <div className='flex flex-y-center mb-2 gap-2'>                                <Label size={"sm"} className=" text-muted-foreground py-0.5">Video bitrate (recommended {selectedQuality.optimalBitrate} kbps)</Label>                                { selectedQuality.currentBitrate && selectedQuality.optimalBitrate !== selectedQuality.currentBitrate &&                                    <Button role="button" size={"auto"} className="px-2 text-xs py-0.5 rounded-sm"                                            onClick={() => {                                                selectedQuality.currentBitrate = selectedQuality.optimalBitrate;                                                setForceUpdate(prev => !prev);                                            }}>                                        Reset                                    </Button>                                }                            </div>                            <SliderWithLabel labelAfter={" kbps"}                                             value={[selectedQuality.currentBitrate || selectedQuality.optimalBitrate]}                                             onValueChange={o => {                                                 selectedQuality.currentBitrate = o[0];                                                 setForceUpdate(prev => !prev);                                             }}                                             min={selectedQuality.minBitrate}                                             max={selectedQuality.maxBitrate}                            />                        </div>                    }                    {/* Video settings */}                    <Label size={"lg"} className="mb-3">Video settings</Label>                    <div className="ml-2 px-3 pt-1 flex flex-col border-l border-border border-dashed">                        <Label size={"md"} className="ml-1 ">                            Select a video codec                            <small className="ml-1 text-xs font-normal text-muted-foreground">                                (from better to worse)                            </small>                        </Label>                        <Select defaultValue={selectedCodec.name} required={true} onValueChange={(value) => {                            const codec = schema.codecs.find(c => c.name === value);                            if (codec) {                                const codecPresets = getCodecPresets(codec);                                setSelectedCodec(codec);                                setCodecPresets(codecPresets);                            }                        }}>                            <SelectTrigger className="w-full my-1">                                <SelectValue placeholder="Select a video codec" />                            </SelectTrigger>                            <SelectContent>                                <SelectGroup >                                    <SelectLabel>Available codecs</SelectLabel>                                    {                                        schema.codecs.map((codec) => (                                            <SelectItem key={codec.name} value={codec.name}>                                                {codec.name} ({codec.description}{codec.provider ? ", " + EVideoCodecProvider[codec.provider] : ""})                                            </SelectItem>                                        ))                                    }                                </SelectGroup>                            </SelectContent>                        </Select>                        <Label size={"md"} className="ml-1">                            Select a video codec preset                        </Label>                        <Select value={codecPreset} onValueChange={setCodecPreset} required={true}>                            <SelectTrigger className="w-full my-1">                                <SelectValue placeholder="Select audio preset" />                            </SelectTrigger>                            <SelectContent>                                <SelectGroup >                                    <SelectLabel>Available presets</SelectLabel>                                    {                                        Object.entries(codecPresets).map(([k, preset]) => {                                            return (                                                <SelectItem key={k} value={k}>                                                    {k} ({codecPresets[k].description})                                                </SelectItem>                                            );                                        })                                    }                                </SelectGroup>                            </SelectContent>                        </Select>                    </div>                    {/* Audio settings */}                    <Label size={"lg"} className="mb-3">Audio settings</Label>                    <div className="ml-2 px-3 pt-1 flex flex-col border-l border-border border-dashed">                        <Label size={"md"} className="ml-1">                            Select an audio codec preset                        </Label>                        <Select value={selectedAudioCodec} onValueChange={setSelectedAudioCodec} required={true}>                            <SelectTrigger className="w-full my-1">                                <SelectValue placeholder="Select audio preset" />                            </SelectTrigger>                            <SelectContent>                                <SelectGroup >                                    <SelectLabel>Available codecs</SelectLabel>                                    {                                        Object.entries(schema.audioCodecs).map(([k, v]) => {                                            return (                                                <SelectItem key={k} value={k}>                                                    {k}                                                </SelectItem>                                            );                                        })                                    }                                </SelectGroup>                            </SelectContent>                        </Select>                        <Label size={"md"} className="ml-1">                            Select an audio bitrate                        </Label>                        <Select value={defaultAudioBitrate.toString()} onValueChange={(value) => {                            setDefaultAudioBitrate(parseInt(value));                        }} required={true}>                            <SelectTrigger className="w-full my-1">                                <SelectValue placeholder="Select audio bitrate" />                            </SelectTrigger>                            <SelectContent>                                <SelectGroup >                                    <SelectLabel>Available bitrates</SelectLabel>                                    {                                        Object.entries(schema.audioBitrates).map(([k, v]) => {                                            return (                                                <SelectItem key={k} value={v.toString()}>                                                    {k} ({v} kbps)                                                </SelectItem>                                            );                                        })                                    }                                </SelectGroup>                            </SelectContent>                        </Select>                    </div>                </>            }        </>    )}